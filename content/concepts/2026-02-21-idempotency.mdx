---
title: "Idempotency"
slug: "2026-02-21-idempotency"
date: "2026-02-21"
category: "Reliability"
difficulty: "Intermediate"
tags: ["Idempotency", "Reliability", "APIs", "Distributed Systems"]
description: "Designing idempotent operations so that retries and duplicate requests never cause unintended side effects"
---

## Overview

An operation is idempotent if performing it multiple times produces the same result as performing it once. In distributed systems, where network failures cause retries and duplicate messages, idempotency is essential for preventing double charges, duplicate records, and corrupted state.

## Naturally Idempotent Operations

Some operations are inherently idempotent:

```sql
-- Idempotent: setting a value (same result no matter how many times)
UPDATE users SET email = 'alice@example.com' WHERE id = 42;

-- NOT idempotent: incrementing (different result each time)
UPDATE accounts SET balance = balance + 100 WHERE id = 42;
```

HTTP methods have expected idempotency semantics:
- **GET, PUT, DELETE** -- Should be idempotent by design
- **POST** -- Not naturally idempotent (needs explicit handling)

## Idempotency Keys

For non-idempotent operations (like creating a payment), use an idempotency key: a unique identifier the client generates and sends with the request.

```python
@app.route("/api/payments", methods=["POST"])
def create_payment():
    idempotency_key = request.headers.get("Idempotency-Key")
    if not idempotency_key:
        return jsonify({"error": "Idempotency-Key header required"}), 400

    # Check if we've already processed this key
    existing = db.execute(
        "SELECT response_body, status_code FROM idempotency_store WHERE key = %s",
        (idempotency_key,)
    ).fetchone()

    if existing:
        return Response(existing.response_body, status=existing.status_code)

    # Process the payment
    try:
        result = payment_provider.charge(request.json)
        response = jsonify(result)
        status = 201

        # Store the result for future duplicate requests
        db.execute(
            "INSERT INTO idempotency_store (key, response_body, status_code) VALUES (%s, %s, %s)",
            (idempotency_key, response.get_data(as_text=True), status)
        )
        return response, status
    except PaymentError as e:
        return jsonify({"error": str(e)}), 400
```

```javascript
// Client sends a unique key with each request
const response = await fetch("/api/payments", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "Idempotency-Key": crypto.randomUUID(), // Unique per logical operation
  },
  body: JSON.stringify({ amount: 2999, currency: "usd" }),
});
```

## Database-Level Idempotency

Use `INSERT ... ON CONFLICT` to make database writes idempotent:

```sql
-- Idempotent insert: upsert pattern
INSERT INTO notifications (user_id, event_type, event_id, message)
VALUES ($1, $2, $3, $4)
ON CONFLICT (user_id, event_id) DO NOTHING;
```

## Message Queue Idempotency

Queues often deliver messages at least once. Your consumer must handle duplicates:

```python
def process_order_event(message):
    event_id = message["event_id"]

    # Check if already processed
    if db.execute("SELECT 1 FROM processed_events WHERE id = %s", (event_id,)).fetchone():
        return  # Already processed, skip

    # Process the event
    with db.transaction():
        create_order(message["order_data"])
        db.execute("INSERT INTO processed_events (id) VALUES (%s)", (event_id,))
```

## Common Pitfalls

- **Race conditions** -- Two identical requests arriving simultaneously can both pass the "not processed" check. Use database constraints or distributed locks.
- **Not storing the full response** -- If you only track "was this processed?", retried requests get a 409 Conflict instead of the original successful response.
- **Relying on request body matching** -- Use a dedicated idempotency key, not request body hashing.

## Best Practices

- Require idempotency keys for all mutating POST endpoints
- Use UUIDs generated by the client for idempotency keys
- Store the complete response (body + status code) for replay
- Set a reasonable TTL on stored keys (24 hours is typical)
- Combine with retry strategies for reliable distributed communication
