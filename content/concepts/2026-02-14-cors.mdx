---
title: "CORS"
slug: "2026-02-14-cors"
date: "2026-02-14"
category: "Security"
difficulty: "Beginner"
tags: ["CORS", "Security", "HTTP", "Web"]
description: "Understanding Cross-Origin Resource Sharing and how browsers enforce same-origin policy for web security"
---

## Overview

Cross-Origin Resource Sharing (CORS) is a browser security mechanism that controls which websites can make requests to your API. It prevents malicious websites from making requests using a visitor's cookies without their knowledge.

```
Access to fetch at 'https://api.example.com/data' from origin
'https://myapp.com' has been blocked by CORS policy
```

CORS is not a bug -- it is a security feature.

## The Same-Origin Policy

Browsers enforce a same-origin policy: JavaScript on one origin cannot freely make requests to a different origin. Two URLs share the same origin only if they have the same **protocol**, **host**, and **port**.

```
https://myapp.com/page     ← origin: https://myapp.com

Same origin:
  https://myapp.com/other     ✅ same protocol, host, port

Different origin:
  http://myapp.com/page       ❌ different protocol
  https://api.myapp.com/data  ❌ different host (subdomain counts)
  https://myapp.com:8080/     ❌ different port
```

## How CORS Works

### Simple Requests

For basic GET/POST requests, the browser sends the request and checks the response headers:

```
Browser → GET /api/data, Origin: https://myapp.com
Server  ← Access-Control-Allow-Origin: https://myapp.com
Browser → Allows JavaScript to read the response ✅
```

### Preflight Requests

For requests with custom headers, non-standard methods, or `Content-Type: application/json`, the browser sends an OPTIONS request first:

```
Browser → OPTIONS /api/users/42
          Access-Control-Request-Method: PUT
          Access-Control-Request-Headers: Content-Type, Authorization

Server  ← Access-Control-Allow-Origin: https://myapp.com
          Access-Control-Allow-Methods: GET, POST, PUT, DELETE
          Access-Control-Allow-Headers: Content-Type, Authorization
          Access-Control-Max-Age: 86400

Browser → PUT /api/users/42 (actual request proceeds)
```

## Server Configuration

```javascript
// Express.js
const cors = require("cors");

app.use(cors({
  origin: ["https://myapp.com", "https://staging.myapp.com"],
  methods: ["GET", "POST", "PUT", "DELETE"],
  allowedHeaders: ["Content-Type", "Authorization"],
  credentials: true,
  maxAge: 86400,
}));
```

```python
# Django (django-cors-headers)
CORS_ALLOWED_ORIGINS = [
    "https://myapp.com",
    "https://staging.myapp.com",
]
CORS_ALLOW_CREDENTIALS = True
```

## Credentials and Cookies

To send cookies cross-origin, both sides must opt in:

```javascript
// Client
fetch("https://api.example.com/data", { credentials: "include" });
```

```
// Server response (must be specific origin, NOT *)
Access-Control-Allow-Origin: https://myapp.com
Access-Control-Allow-Credentials: true
```

## Common Pitfalls

- **Using `*` with credentials** -- The browser rejects `Access-Control-Allow-Origin: *` when credentials are included. You must specify the exact origin.
- **Missing OPTIONS handler** -- If your server returns 404 for OPTIONS, every preflight fails.
- **CORS middleware in wrong order** -- CORS headers must be set before your routes handle the request.
- **Thinking CORS protects the server** -- CORS is browser-only. Curl, Postman, and server-to-server requests bypass it entirely.
- **Reflecting any origin** -- Dynamically echoing whatever `Origin` header the browser sends disables CORS protection. Validate against an allowlist.

## Best Practices

- Specify exact allowed origins rather than `*` in production
- Set `Access-Control-Max-Age` to reduce preflight requests (86400 is common)
- Keep allowed headers minimal
- Handle CORS at the reverse proxy level for consistency across services
- Remember CORS is a browser feature -- always authenticate on the server regardless
