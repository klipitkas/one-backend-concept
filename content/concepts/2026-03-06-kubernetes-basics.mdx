---
title: "Kubernetes Basics"
slug: "2026-03-06-kubernetes-basics"
date: "2026-03-06"
category: "Infrastructure"
difficulty: "Intermediate"
tags: ["Kubernetes", "Containers", "Orchestration", "Infrastructure"]
description: "The core Kubernetes concepts every backend developer should understand -- Pods, Deployments, Services, and how they fit together"
---

## Overview

Kubernetes (K8s) is a container orchestration platform. It takes your containerized applications and handles deployment, scaling, networking, and self-healing. Instead of SSH-ing into servers to deploy your code, you declare what you want (e.g., "run 3 copies of my API") and Kubernetes makes it happen.

## Core Concepts

### Pod

The smallest deployable unit. Usually one container, but can be multiple containers that share networking and storage.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: api-server
spec:
  containers:
    - name: api
      image: myapp/api:1.2.3
      ports:
        - containerPort: 8080
      resources:
        requests:
          memory: "128Mi"
          cpu: "250m"
        limits:
          memory: "256Mi"
          cpu: "500m"
```

### Deployment

Manages a set of identical Pods. Handles rolling updates and rollbacks.

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-deployment
spec:
  replicas: 3                    # Run 3 copies
  selector:
    matchLabels:
      app: api
  template:
    metadata:
      labels:
        app: api
    spec:
      containers:
        - name: api
          image: myapp/api:1.2.3
          ports:
            - containerPort: 8080
          env:
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: db-credentials
                  key: url
          livenessProbe:
            httpGet:
              path: /healthz
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 15
          readinessProbe:
            httpGet:
              path: /readyz
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 10
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1                # Add 1 new pod before removing old ones
      maxUnavailable: 0          # Never have fewer than 3 running pods
```

### Service

A stable network endpoint that routes traffic to Pods. Pods come and go, but the Service address stays the same.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: api-service
spec:
  selector:
    app: api                     # Routes to pods with label app=api
  ports:
    - port: 80                   # Service listens on port 80
      targetPort: 8080           # Forwards to pod port 8080
  type: ClusterIP                # Internal only (default)
```

Other services reach the API at `http://api-service:80` (Kubernetes DNS resolves the service name).

### ConfigMap and Secret

Externalize configuration from your container images.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: api-config
data:
  LOG_LEVEL: "info"
  CACHE_TTL: "300"
---
apiVersion: v1
kind: Secret
metadata:
  name: db-credentials
type: Opaque
stringData:
  url: "postgresql://user:pass@db-host:5432/mydb"
```

### Ingress

Exposes HTTP routes from outside the cluster to Services inside.

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: api-ingress
spec:
  rules:
    - host: api.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: api-service
                port:
                  number: 80
```

## How It All Fits Together

```
Internet
  ↓
Ingress (api.example.com → api-service)
  ↓
Service (api-service:80 → pod:8080)
  ↓
Deployment (manages 3 replicas)
  ↓
Pod → Pod → Pod (each running your container)
```

## Common kubectl Commands

```bash
# See what's running
kubectl get pods
kubectl get deployments
kubectl get services

# Deploy or update
kubectl apply -f deployment.yaml

# Check pod logs
kubectl logs api-deployment-abc123

# Debug a failing pod
kubectl describe pod api-deployment-abc123

# Scale up
kubectl scale deployment api-deployment --replicas=5

# Rollback a bad deployment
kubectl rollout undo deployment api-deployment
```

## Common Pitfalls

- **No resource limits** -- A container without memory limits can consume all node memory and crash other pods.
- **No health checks** -- Without liveness and readiness probes, Kubernetes can't restart broken pods or route traffic away from unready ones.
- **Hardcoded configuration** -- Use ConfigMaps and Secrets. Don't bake connection strings into container images.
- **Using `latest` tag** -- `image: myapp:latest` doesn't tell you which version is deployed. Use specific tags like `myapp:1.2.3`.

## Best Practices

- Always set resource requests and limits
- Use health checks (liveness and readiness probes)
- Use specific image tags, never `latest`
- Store configuration in ConfigMaps, secrets in Secrets
- Use namespaces to isolate environments (dev, staging, prod)
- Set up Horizontal Pod Autoscaler for automatic scaling
